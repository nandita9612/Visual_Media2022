 # -*- coding: utf-8 -*-
"""colorfill.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hp7srUFRtRS_PZocAs6NrXVxLF6k7pXi
"""

import numpy as np
import cv2
#from google.colab.patches import cv2_imshow

def getline(x0, y0, x1, y1):
  points = []
    
  if abs(x1 - x0) >= abs(y1-y0): #slope is less than 1
    #formula to check the slope of the line
    if x0 < x1:  
      for x in range(x0,x1+1):
        y = (x - x0) * (y1 - y0) / (x1 - x0) + y0
        yint = int(y)
        points.append((x, yint))
        
    else:
      for x in range(x1, x0-1):
        y = (x - x0) * (y1 - y0) / (x1 - x0) + y0
        yint = int(y)
        points.append((x, yint))
    return points

  else: #slope is greater than one
    if y0 < y1:  
      for y in range(y0,y1+1):
        x = (y - y0) * (x1 - x0) / (y1 - y0) + x0
        xint = int(x)
        points.append((xint, y))

    else:
      for y in range(y1, y0-1):
        x = (y - y0) * (x1 - x0) / (y1 - y0) + x0
        xint = int(x)
        points.append((xint, y))
    return points

def drawline(canvas, x0,y0,x1,y1, color=(255,255,255)):
  xys = getline(x0,y0,x1,y1)
  for xy in xys:
    x, y = xy
    canvas[y,x, :] = color
  return

def drawLinePQ(canvas, p, q, color):
  drawline(canvas, p[0], p[1], q[0], q[1], color)
  return

def deg2rad(deg):
  rad = deg * np.pi/180
  return rad

def getregularpolygon(N):
  delta_degree = 360./N
  points = []
  for i in range(N):
    degree = i*delta_degree
    radian = deg2rad(degree)
    x = np.cos(radian)
    y = np.sin(radian)
    points.append((x,y,1))

  points = np.array(points)
  return points

def getrectangle(h,w,color=(0,0,255)):
    rectangle_vertices = np.array([
        [0,w,1],
        [0,0,1], 
        [h,0,1],
        [h,w,1]])
    
    return rectangle_vertices

def gettriangle(h,w,color=(255,0,255)):
    triangle_vertices = np.array([
        [w,h//2,1],
        [0,h,1], 
        [0,0,1]])
    
    return triangle_vertices
    
def drawPolygon(canvas, pts, color = (255,255,255), axis=False):
  for k in range(pts.shape[0]-1):
    drawline(canvas, pts[k,0], pts[k,1], pts[k+1,0], pts[k+1, 1], color)

  drawLinePQ(canvas, pts[-1], pts[0], color)

  #if axis == True: # center - pts[0]
   # center = np.mean(pts, axis=0).astype('int')
    #drawLinePQ(canvas, center, pts[0], color=(0, 128, 128))

  return

def makeTmat(a,b):
    #return np.array([[1,0,0], [0,1,0], [a, b, 1]])
    Tmat = np.eye(3,3)
    Tmat[0,2] = a
    Tmat[1,2] = b
    return Tmat

def makeRmat(degree):
  r = deg2rad(degree)
  c, s = np.cos(r), np.sin(r)
  Rmat = np.eye(3,3)
  Rmat[0,0] = c
  Rmat[0,1] = -s
  Rmat[1,0] = s
  Rmat[1,1] = c
  return Rmat

def getcentre(pts):
  center = np.mean(pts, axis=0).astype('int')
  return np.array(center)

def getbigpolygon(N,theta, scale, canvas, color=(255,255,255)):
  points = getregularpolygon(N)
  points = points*scale
  points[:,2] = 1

  T = makeTmat(canvas.shape[0]/2, canvas.shape[1]/2)
  R = makeRmat(theta)

  Q = R @ points.T
  Q = (T @ Q).T

  Q = Q.astype('int')
  

  return Q

'''function to get all the boundry points of the polygon:
recycled the drawpolygon() function'''

def getboundrypoints(pts):
  lines = [] #create an empty list
  for k in range(pts.shape[0]-1):
    #append array of points between 2 points to lines
    lines.append(np.array(getline(pts[k,0], pts[k,1], pts[k+1,0], pts[k+1, 1])))

  #create a seperate array for the last line completing the polygon
  lastline = np.array(getline(pts[-1][0],pts[-1][1],pts[0][0],pts[0][1]))

  #merging all the arrays in lines to one array 
  lines = np.concatenate(lines, axis=0 )

  #merging lines and lastline points in one final array of points
  finallist = np.concatenate((lines, lastline), axis=0)
  return finallist

'''function to draw the lines from every corner of the polygon to all the other
boundry points of the polygon which will fill the polygon'''

def fillpolygon(canvas, pts, color = (255,0,0)):
  boundrypoints = getboundrypoints(pts)
  for i in pts: #corner of the polygon
    for k in boundrypoints: #all points in the boundary of the polygon
      drawline(canvas, i[0], i[1], k[0], k[1], color)  

def main():
    width = 700
    height = 700
    window = np.zeros((height, width, 3), dtype = 'uint8')
    rect_h = 200
    rect_w = 90
    tri_w = 150
    tri_h = 80
    T0 = makeTmat((width/2-rect_w/2), (height-(rect_h + 50)))
    R1 = 20
  
    while True:
        color = np.random.randint(0,255, 3)
        
        building = getrectangle(rect_w, rect_h).T
        building = ((T0 @ building).T).astype('int')
        drawPolygon(window, building)
        #rect_lines= getboundrypoints(building)
        fillpolygon(window, building, (255,255,0))
        
        roof_a,roof_b = (building[0][0]+(building[2][0] - building[0][0])//2, building[1][1])
    
        T1 = makeTmat(roof_a,roof_b)
        wr1 = makeRmat(R1)
        wr2 = makeRmat(R1+90)
        wr3 = makeRmat(R1+180)
        wr4 = makeRmat(R1+270)
        T2 = makeTmat(-tri_w,-tri_h//2)

        wing1 = gettriangle(tri_h, tri_w).T
        wing1 = ((T1 @ wr1 @ T2 @ wing1).T).astype('int')

        wing2 = gettriangle(tri_h, tri_w).T
        wing2 = ((T1 @ wr2 @ T2 @ wing2).T).astype('int')
        
        wing3 = gettriangle(tri_h, tri_w).T
        wing3 = ((T1 @ wr3 @ T2 @ wing3).T).astype('int')

        wing4 = gettriangle(tri_h, tri_w).T
        wing4 = ((T1 @ wr4 @ T2 @ wing4).T).astype('int')
        
        fillpolygon(window,wing1, color)
        fillpolygon(window,wing2, color)
        fillpolygon(window,wing3, color)
        fillpolygon(window,wing4, color)  

        R1 += 30

        cv2.imshow("window", window)   
        window = np.zeros((height, width, 3), dtype = 'uint8')
        
    
        if cv2.waitKey(1) == 27: break


main()

